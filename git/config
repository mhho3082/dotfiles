[user]
    # Please use `git config --global user.name "Your Name"`
    # and `git config --global user.email "example@example.com"` to set these values;
    # If you run `make` to copy dotfiles, these will be restored automatically

# ---

[core]
    editor = nvim
    eol = lf
    autocrlf = false

[code]
    editor = nvim

[init]
    defaultBranch = main

[branch]
    sort = -committerdate

[tag]
    sort = version:refname

[pull]
    rebase = true

[push]
    default = simple
    autoSetupRemote = true
    followTags = true

[fetch]
    prune = true
    pruneTags = true
    all = true

[rebase]
    autoSquash = true
    autoStash = true
    updateRefs = true

[gc]
    # Disable automatic gc, as it can be disruptive
    # https://donatstudios.com/yagni-git-gc
    # https://stackoverflow.com/a/87445
    # To do garbage collection, use `git gc` or `git autoclean` (alias, see below)
    auto = 0

# ---

# Some ideas from https://github.com/mathiasbynens/dotfiles

# Note: complex alias using `f() {}; f` format can use bash autocompletion
# by prefixing with a null command `:`, e.g. `!f() { : git checkout ; ... }; f`;
# see https://github.com/git/git/blob/master/contrib/completion/git-completion.bash

[alias]
    a = add
    aa = add --all
    ai = add --interactive
    ap = add --patch
    an = add --all --intent-to-add # Add new: for adding (but not staging) new files

    b = branch

    c = commit
    ci = commit --interactive

    # Simple commit tool
    ca = "!git add -A && git commit && if git remote | grep . > /dev/null; then git push; fi"
    # Do not open editor for the commit message
    cam = "!f() { [ -n \"$1\" ] && git add -A && git commit -m \"$@\" && if git remote | grep . > /dev/null; then git push; fi; }; f"

    co = checkout
    cl = clone
    cp = cherry-pick

    # Diff display options
    diff-shorthand = "!f() { : git diff ; ~/.config/git/git-diff-shorthand.sh $@; }; f"
    d   = diff-shorthand _
    df  = diff-shorthand f
    dw  = diff-shorthand w
    ds  = diff-shorthand s
    dn  = diff-shorthand n

    f = fetch
    # Fetch remote branches, and update existing local branches (without creating new ones)
    fe = "!f() { git fetch ${1:-$(git default-remote)} && git branch | grep -v '^*' | xargs -P4 -I{} git fetch ${1:-$(git default-remote)} {}:{}; }; f"
    # Fetch remote branches, and update / create local branches to match
    fa = "!f() { git fetch ${1:-$(git default-remote)} && git branch -r | grep -v \\> | grep -v $(git rev-parse --abbrev-ref HEAD) | sed \"s@${1:-$(git default-remote)}/@@\" | xargs -P4 -I{} git fetch ${1:-$(git default-remote)} {}:{}; }; f"

    m = merge
    # Merge branches without switching to them
    # Usage: git mr <source-branch> <target-branch-1> <target-branch-2> ...
    # Note that the current branch can be the source or one of the targets
    mr = "!f() { : git checkout ; local SRC=$1 CURR=$(git rev-parse --abbrev-ref HEAD) DST WT_DIR; shift; if ! git rev-parse --verify \"$SRC\" >/dev/null 2>&1; then echo \"Error: Source branch '$SRC' does not exist.\" >&2; return 1; fi; for DST in \"$@\"; do if [ \"$DST\" = \"$CURR\" ]; then if git merge --no-edit \"$SRC\"; then echo \"Successfully merged '$SRC' into '$DST'.\"; else echo \"Merge of '$SRC' into '$DST' failed. Branch not updated.\" >&2; git merge --abort >/dev/null 2>&1; fi; else WT_DIR=$(mktemp -d /tmp/git-worktree.XXXXXX); if ! git worktree add --quiet \"$WT_DIR\" \"$DST\" >/dev/null; then echo \"Error: Could not create worktree for '$DST'.\" >&2; rm -rf \"$WT_DIR\"; continue; fi; if git -C \"$WT_DIR\" merge --no-edit \"$SRC\"; then echo \"Successfully merged '$SRC' into '$DST'.\"; else echo \"Merge of '$SRC' into '$DST' failed. Branch not updated.\" >&2; fi; git worktree remove --force \"$WT_DIR\" >/dev/null 2>&1 || rm -rf \"$WT_DIR\"; fi; echo; done; }; f"

    r = rebase
    ri = rebase --interactive
    # Modify commits before pushing to upstream
    riu = rebase --interactive @{upstream}

    # https://www.reddit.com/r/programming/comments/1febgy/handy_git_tips_to_stop_you_getting_fired/
    # Handle merge conflicts easily
    ours = "!f() { : git add ; git checkout --ours $@ && git add $@; }; f"
    theirs = "!f() { : git add ; git checkout --theirs $@ && git add $@; }; f"

    p = push
    pa = push --all
    pu = pull
    # Fast-forward pull only, fail otherwise
    pf = pull --ff-only
    # Stash changes away before pull
    ps = pull --rebase --autostash
    # The more aggressive version
    pss = "!git stash; git pull --rebase; git stash pop"

    # Force local changes up to remotes
    force = push --all --force-with-lease
    # Save and push all temporary changes in case of emergency
    fire = "!git checkout -B \"EMERGENCY-$(git config user.email)\"; git add -A; git commit -m \"WIP: Emergency commit on $(date +%d/%m/%Y\\ %H:%M:%S)\"; git push --force-with-lease"

    st = status --short --branch

    s = stash
    sn = stash --include-untracked # Stash, with new files
    si = stash --patch
    sp = stash pop

    # Checkout or create branch
    # https://stackoverflow.com/q/26961371
    # Adjusted to run on both bash and dash
    cd = "!f() { : git checkout ; b=\"$1\"; if [ -z \"$b\" ]; then b=$(git default-branch); fi; if git rev-parse --verify \"$b\" >/dev/null 2>&1; then git checkout \"$b\"; else printf 'Revision specifier %s not found, create branch %s? [y/N] ' \"$b\" \"$b\"; read answer; case \"$answer\" in [yY]) git checkout -b \"$b\" ;; esac; fi; }; f"

    # https://joshtronic.com/2020/08/09/how-to-get-the-default-git-branch/
    # Also handles repos without remote by responding the config's default branch instead
    # Adjusted to run on both bash and dash
    default-branch = "!f() { b=$(git symbolic-ref refs/remotes/$(git default-remote)/HEAD 2>/dev/null); if [ -n \"$b\" ]; then echo \"$b\" | sed 's@^refs/remotes/'$(git default-remote)'/@@'; else git config --get init.defaultBranch; fi; }; f"
    default-remote = "!f() { r=$(git remote); if [ -n \"$r\" ]; then echo \"$r\" | head -n1; else echo \"origin\"; fi; }; f"

    # https://stackoverflow.com/a/34467298
    l = l1
    l1 = l1-specific --all
    l2 = l2-specific --all
    l3 = l3-specific --all

    l1-specific = log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(auto)%d%C(reset)'
    l2-specific = log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset)%C(auto)%d%C(reset)%n''          %C(white)%s%C(reset) %C(dim white)- %an%C(reset)'
    l3-specific = log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset) %C(bold cyan)(committed: %cD)%C(reset) %C(auto)%d%C(reset)%n''          %C(white)%s%C(reset)%n''          %C(dim white)- %an <%ae> %C(reset) %C(dim white)(committer: %cn <%ce>)%C(reset)'

    # whatchanged
    # For particular revisions
    w = show --stat --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(auto)%d%C(reset)'
    # As log
    lw = log --stat --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(auto)%d%C(reset)' --no-merges

    # https://gggritso.com/human-git-aliases
    # Remove all changes from staging
    unstage = reset --mixed HEAD --
    # Remove all changes made, including untracked files
    discard = "!git reset --hard HEAD && git clean -d -f"
    # Undo last commit softly
    uncommit = reset HEAD~1 --mixed
    # Amend the recent commit
    amend = commit --amend
    overwrite = commit --amend --no-edit --reset-author

    # Remove unused objects in the .git directory
    autoclean = gc --prune=now --aggressive

    # Show verbose data
    sha = rev-parse --short HEAD
    tags = tag -l
    branches = branch -vv --sort=-committerdate
    remotes = remote --verbose
    contributors = shortlog --summary --numbered --no-merges
    stashes = stash list
    conflicts = diff --name-only --diff-filter=U

    # Make an archive of the current repo
    quick-archive = "!f() { d=\"$(git rev-parse --show-toplevel)\"; [ -d $d ] && pushd \"$d/..\" && tar cf \"$(basename $d).tar\" \"$(basename $d)\" && popd; }; f"

    # Initiate a git repo
    quick-init = "!f() { if [ ! -d .git ]; then git init && git add -A && git commit -m \"feat: Repo init\"; else printf 'Git repository already exists, fully overwrite it? [y/N] '; read answer; case \"$answer\" in [yY]) rm -rf .git && git init && git add -A && git commit -m \"feat: Repo init\" ;; esac; fi; }; f"

    # Generate gitignore file based on https://github.com/github/gitignore
    ignore = "!~/.config/git/gitignore.sh"

# ---

[column]
    ui = auto

[log]
    decorate = true
    abbrevCommit = true

[format]
    pretty = "%C(magenta)%h%Creset -%C(red)%d%Creset %s %C(green)(%cr) %C(cyan)<%an>%Creset"

[pager]
    difftool = true

# ---

[diff]
    tool = difftastic
    algorithm = histogram
    colorMoved = plain
    mnemonicPrefix = true
    renames = true

[difftool]
    prompt = false

[difftool "difftastic"]
    cmd = difft "$LOCAL" "$REMOTE"


[difftool "nvimdiff"]
    cmd = !"nvim -d \"$LOCAL\" \"$REMOTE\""

[difftool "vscode"]
    cmd = code --wait --diff $LOCAL $REMOTE

# ---

[merge]
    tool = nvim
    conflictstyle = zdiff3

[mergetool]
    prompt = false

[mergetool "nvim"]
    cmd = !"nvim -f -c \"Gdiffsplit!\" \"$MERGED\""

[mergetool "vscode"]
    cmd = code --wait $MERGED

# ---

[filter "lfs"]
    smudge = git-lfs smudge -- %f
    process = git-lfs filter-process
    required = true
    clean = git-lfs clean -- %f

# ---

[credential "https://github.com"]
    helper = !/usr/bin/env gh auth git-credential

[credential "https://gist.github.com"]
    helper = !/usr/bin/env gh auth git-credential

# vim:ft=gitconfig
